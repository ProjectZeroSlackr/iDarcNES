/*
 * tiledraw.c
 *
 * drawing routines for tilecached VDPs
 */

/* $Id: tiledraw.c,v 1.5 1999/11/27 23:47:03 nyef Exp $ */

#include "tiledraw.h"

void tiledraw_8(unsigned char *cur_vbp, unsigned char **tiles, unsigned char **palettes, int num_tiles, int finescroll)
{
    int i;
    unsigned char *palette;
    unsigned char *tiledata;

    palette = *palettes++;
    tiledata = *tiles++;
    if (!tiledata) {
	cur_vbp += (8 - finescroll);
    } else {
	tiledata += finescroll;
	switch (finescroll) {
	case 0:
	    if (*(tiledata+0))
		*(cur_vbp+0) = palette[*(tiledata+0)];
	    if (*(tiledata+1))
		*(cur_vbp+1) = palette[*(tiledata+1)];
	    if (*(tiledata+2))
		*(cur_vbp+2) = palette[*(tiledata+2)];
	    if (*(tiledata+3))
		*(cur_vbp+3) = palette[*(tiledata+3)];
	    if (*(tiledata+4))
		*(cur_vbp+4) = palette[*(tiledata+4)];
	    if (*(tiledata+5))
		*(cur_vbp+5) = palette[*(tiledata+5)];
	    if (*(tiledata+6))
		*(cur_vbp+6) = palette[*(tiledata+6)];
	    if (*(tiledata+7))
		*(cur_vbp+7) = palette[*(tiledata+7)];
	    cur_vbp+=8;
	    tiledata+=8;
	    break;
	case 1:
	    if (*(tiledata+0))
		*(cur_vbp+0) = palette[*(tiledata+0)];
	    if (*(tiledata+1))
		*(cur_vbp+1) = palette[*(tiledata+1)];
	    if (*(tiledata+2))
		*(cur_vbp+2) = palette[*(tiledata+2)];
	    if (*(tiledata+3))
		*(cur_vbp+3) = palette[*(tiledata+3)];
	    if (*(tiledata+4))
		*(cur_vbp+4) = palette[*(tiledata+4)];
	    if (*(tiledata+5))
		*(cur_vbp+5) = palette[*(tiledata+5)];
	    if (*(tiledata+6))
		*(cur_vbp+6) = palette[*(tiledata+6)];
	    cur_vbp+=7;
	    tiledata+=7;
	    break;
	case 2:
	    if (*(tiledata+0))
		*(cur_vbp+0) = palette[*(tiledata+0)];
	    if (*(tiledata+1))
		*(cur_vbp+1) = palette[*(tiledata+1)];
	    if (*(tiledata+2))
		*(cur_vbp+2) = palette[*(tiledata+2)];
	    if (*(tiledata+3))
		*(cur_vbp+3) = palette[*(tiledata+3)];
	    if (*(tiledata+4))
		*(cur_vbp+4) = palette[*(tiledata+4)];
	    if (*(tiledata+5))
		*(cur_vbp+5) = palette[*(tiledata+5)];
	    cur_vbp+=6;
	    tiledata+=6;
	    break;
	case 3:
	    if (*(tiledata+0))
		*(cur_vbp+0) = palette[*(tiledata+0)];
	    if (*(tiledata+1))
		*(cur_vbp+1) = palette[*(tiledata+1)];
	    if (*(tiledata+2))
		*(cur_vbp+2) = palette[*(tiledata+2)];
	    if (*(tiledata+3))
		*(cur_vbp+3) = palette[*(tiledata+3)];
	    if (*(tiledata+4))
		*(cur_vbp+4) = palette[*(tiledata+4)];
	    cur_vbp+=5;
	    tiledata+=5;
	    break;
	case 4:
	    if (*(tiledata+0))
		*(cur_vbp+0) = palette[*(tiledata+0)];
	    if (*(tiledata+1))
		*(cur_vbp+1) = palette[*(tiledata+1)];
	    if (*(tiledata+2))
		*(cur_vbp+2) = palette[*(tiledata+2)];
	    if (*(tiledata+3))
		*(cur_vbp+3) = palette[*(tiledata+3)];
	    cur_vbp+=4;
	    tiledata+=4;
	    break;
	case 5:
	    if (*(tiledata+0))
		*(cur_vbp+0) = palette[*(tiledata+0)];
	    if (*(tiledata+1))
		*(cur_vbp+1) = palette[*(tiledata+1)];
	    if (*(tiledata+2))
		*(cur_vbp+2) = palette[*(tiledata+2)];
	    cur_vbp+=3;
	    tiledata+=3;
	    break;
	case 6:
	    if (*(tiledata+0))
		*(cur_vbp+0) = palette[*(tiledata+0)];
	    if (*(tiledata+1))
		*(cur_vbp+1) = palette[*(tiledata+1)];
	    cur_vbp+=2;
	    tiledata+=2;
	    break;
	case 7:
	    if (*(tiledata+0))
		*(cur_vbp+0) = palette[*(tiledata+0)];
	    cur_vbp++;
	    tiledata++;
	    break;
	}
    }
    
    for (i = num_tiles; i > 1; i--) {
	palette = *palettes++;
	tiledata = *tiles++;
	if (!tiledata) {
	    cur_vbp += 8;
	} else {
	    if (*(tiledata+0))
		*(cur_vbp+0) = palette[*(tiledata+0)];
	    if (*(tiledata+1))
		*(cur_vbp+1) = palette[*(tiledata+1)];
	    if (*(tiledata+2))
		*(cur_vbp+2) = palette[*(tiledata+2)];
	    if (*(tiledata+3))
		*(cur_vbp+3) = palette[*(tiledata+3)];
	    if (*(tiledata+4))
		*(cur_vbp+4) = palette[*(tiledata+4)];
	    if (*(tiledata+5))
		*(cur_vbp+5) = palette[*(tiledata+5)];
	    if (*(tiledata+6))
		*(cur_vbp+6) = palette[*(tiledata+6)];
	    if (*(tiledata+7))
		*(cur_vbp+7) = palette[*(tiledata+7)];
	    cur_vbp+=8;
	    tiledata+=8;
	}
    }
    
    if (finescroll) {
	palette = *palettes++;
	tiledata = *tiles++;
	if (tiledata) {
	    switch (finescroll) {
	case 7:
	    if (*(tiledata+0))
		*(cur_vbp+0) = palette[*(tiledata+0)];
	    if (*(tiledata+1))
		*(cur_vbp+1) = palette[*(tiledata+1)];
	    if (*(tiledata+2))
		*(cur_vbp+2) = palette[*(tiledata+2)];
	    if (*(tiledata+3))
		*(cur_vbp+3) = palette[*(tiledata+3)];
	    if (*(tiledata+4))
		*(cur_vbp+4) = palette[*(tiledata+4)];
	    if (*(tiledata+5))
		*(cur_vbp+5) = palette[*(tiledata+5)];
	    if (*(tiledata+6))
		*(cur_vbp+6) = palette[*(tiledata+6)];
	    cur_vbp+=7;
	    tiledata+=7;
	    break;
	case 6:
	    if (*(tiledata+0))
		*(cur_vbp+0) = palette[*(tiledata+0)];
	    if (*(tiledata+1))
		*(cur_vbp+1) = palette[*(tiledata+1)];
	    if (*(tiledata+2))
		*(cur_vbp+2) = palette[*(tiledata+2)];
	    if (*(tiledata+3))
		*(cur_vbp+3) = palette[*(tiledata+3)];
	    if (*(tiledata+4))
		*(cur_vbp+4) = palette[*(tiledata+4)];
	    if (*(tiledata+5))
		*(cur_vbp+5) = palette[*(tiledata+5)];
	    cur_vbp+=6;
	    tiledata+=6;
	    break;
	case 5:
	    if (*(tiledata+0))
		*(cur_vbp+0) = palette[*(tiledata+0)];
	    if (*(tiledata+1))
		*(cur_vbp+1) = palette[*(tiledata+1)];
	    if (*(tiledata+2))
		*(cur_vbp+2) = palette[*(tiledata+2)];
	    if (*(tiledata+3))
		*(cur_vbp+3) = palette[*(tiledata+3)];
	    if (*(tiledata+4))
		*(cur_vbp+4) = palette[*(tiledata+4)];
	    cur_vbp+=5;
	    tiledata+=5;
	    break;
	case 4:
	    if (*(tiledata+0))
		*(cur_vbp+0) = palette[*(tiledata+0)];
	    if (*(tiledata+1))
		*(cur_vbp+1) = palette[*(tiledata+1)];
	    if (*(tiledata+2))
		*(cur_vbp+2) = palette[*(tiledata+2)];
	    if (*(tiledata+3))
		*(cur_vbp+3) = palette[*(tiledata+3)];
	    cur_vbp+=4;
	    tiledata+=4;
	    break;
	case 3:
	    if (*(tiledata+0))
		*(cur_vbp+0) = palette[*(tiledata+0)];
	    if (*(tiledata+1))
		*(cur_vbp+1) = palette[*(tiledata+1)];
	    if (*(tiledata+2))
		*(cur_vbp+2) = palette[*(tiledata+2)];
	    cur_vbp+=3;
	    tiledata+=3;
	    break;
	case 2:
	    if (*(tiledata+0))
		*(cur_vbp+0) = palette[*(tiledata+0)];
	    if (*(tiledata+1))
		*(cur_vbp+1) = palette[*(tiledata+1)];
	    cur_vbp+=2;
	    tiledata+=2;
	    break;
	case 1:
	    if (*(tiledata+0))
		*(cur_vbp+0) = palette[*(tiledata+0)];
	    cur_vbp++;
	    tiledata++;
	    break;
	    }
	}
    }
}

/*
 * $Log: tiledraw.c,v $
 * Revision 1.5  1999/11/27 23:47:03  nyef
 * changed to allow null pointers for tile data (treats as a blank tile)
 *
 * Revision 1.4  1999/11/26 02:25:07  nyef
 * converted to use *pointer++ instead of pointer[index]
 * reversed the index in the for loop
 *
 * Revision 1.3  1999/11/23 03:29:53  nyef
 * fixed a bug with finescroll on the right side of the screen
 *
 * Revision 1.2  1999/11/23 03:21:53  nyef
 * changed to use new tiledraw interface
 *
 * Revision 1.1  1999/11/23 01:41:06  nyef
 * Initial revision
 *
 */
